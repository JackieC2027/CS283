1. In this assignment I suggested you use `fgets()` to get user input in the main while loop. Why is `fgets()` a good choice for this application?

    > **Answer**: fgets() would be the proper choice for this application because of the function will stop reading after an EOF or newline, as stated in the instrucitons, which can allows us to parse and process one line at a time. By implementing the shell with a complete "line" of user input, fgets can easily parse through the comments since EOF/newlines are used to separate the completed lines.

2. You needed to use `malloc()` to allocte memory for `cmd_buff` in `dsh_cli.c`. Can you explain why you needed to do that, instead of allocating a fixed-size array?

    > **Answer**: It is necessary to use malloc() to allocate memory for cmd_buff within the dsh_cli.c file because having dynamic memory allocation can support different input sizes, instead of fixed amounts of the command buffer. It is possible that all of the memory might not be fully used, so allocating this memory dynamically would account for these instances. Even though a buffer upper bound is set, it still allows us to handle errors like buffer overflows with dynamic memory, reducing potential errors from the user in later stages of deployment.

3. In `dshlib.c`, the function `build_cmd_list(`)` must trim leading and trailing spaces from each command before storing it. Why is this necessary? If we didn't trim spaces, what kind of issues might arise when executing commands in our shell?

    > **Answer**: It is necessary to trim leading and trailing in build_cmd_list() in dshlib.c because when we are tracking the tokens of the entire command, separated by the pipe literal, it allows us to gracefully handle these tokens. With leading and trailing whitespace, this can lead to commands not being recognized from the shell, as the functions are expecting to parse a clean string literal. Especially if we have spaces between some of our commands in our shell, it can even add an extra layer of complexity, which can be avoided with simple string trimming. It could be the case that the shell might believe that these leading and trailing spaces are apart of the command, which could be slightly extra memory that can cause a buffer overflow if not trimmed properly. 

4. For this question you need to do some research on STDIN, STDOUT, and STDERR in Linux. We've learned this week that shells are "robust brokers of input and output". Google _"linux shell stdin stdout stderr explained"_ to get started.

- One topic you should have found information on is "redirection". Please provide at least 3 redirection examples that we should implement in our custom shell, and explain what challenges we might have implementing them.

    > **Answer**: One instance that we can implement redirections into our custom shell would be output redirection. If we were to process all of the commands based on the parsed tokens and instead of outputting the CLI, we can redirect the output to a named text file, this can be used for logging purposes and detailed debugging entries to analyze the output of our program. Some of the challenges that I can think of implementing this redirection example would be handling the file properly, so that we either choose to overwrite or append to the file, ensuring that the file has the necessary permissions for the hsell to acess, or even simply opening the file. Another possible challenge would be if we wanted to output to x number of files, developing a parser for multiple files sounds pretty challenging. Another example of redirection would be input redirection, where we wanted to redirect the input arguments to a given command to retrieve them from a valid file in our file system, instead from sysin, which could be helpful for reading commands to be processed from a file. Some challenges of implementing this input redirection includes but are not limited to file handling, as previously manageed, ensuring the input in the file aligns with the limitations for buffer sizes, command lengths, or execution name lengths for the corresponding shell, as well as ensuring that at least read permissions on granted on the to-be-read-from file. Append redirections can also be implemented within this custom shell, given that we wanted to append all of the output from a cd syscall being made to a logging file, so that we can track what files are being removed or added from the file system. Some challenges that we might encounter with this redirection example might addressed threading for a file, where multiple commands are trying to append to the file, leading to some of the data trying to overwrite the same blocks of memory or even the possibility of race conditions if two requests are made to append to the to-be-appended file at the exact same time. Lastly, the redirection that can be implemented into our shell could be a merge redirection that redirects the errors that we recieve from running a cd command, as well as the corresponding sysout literals into a new file could call for this redirection to be implemented. Some challenges with implementing this may be parsing the actual merge syntax to ensure that the redirection between two sources is being done in the proper order, so that the output strema can cohesively handle the merge in the output file. Any type of error handling for failed commands might still be merged, so this would need to be accounted for.

- You should have also learned about "pipes". Redirection and piping both involve controlling input and output in the shell, but they serve different purposes. Explain the key differences between redirection and piping.

    > **Answer**: The main differences between redirections and piping can be how they are directly interacting with the output and input. As previously stated, redirections will take the output of a certain command that is accurately recongized by our custom shell and depending on the redirection syntax, the output could be transported somewhere, or the source of the input might come from somewhere besides the users. Although piping can be used simultanesouly with redirections, piping is mainly used to connect the output from one command to another command in a complete line of user input, allowing the integrity of the output to be concurrently used for some calculations or process without the need of external files.

- STDERR is often used for error messages, while STDOUT is for regular output. Why is it important to keep these separate in a shell?

    > **Answer**: It is important to keep STDERR and STDOUT needs to be separate in a shell environment because it maintains the integrity of output organization for users. Without the separation betweem STDERR and STDOUT, it might be common for users that are trying to troubleshoot and debug to experience confusion. Users could see a message without a proper declaration of STDERR or STDOUT, so they would be left wondering if the command was sucessful or was this a false positive. With a STDERR message, the user would be able to immediately understand the corresponding error from their command input without reading into the source code to see why might they be experiencing error messages. Vice-versa, the user can simply read the STDOUT messages to see if the command performed the appropriate response for their input. As mentioned before, users can take advantage of STDERR and STDOUT to determine if redirections worked properly, as if the file were missing permissions, error messages that are STDERR can display, whereas if all commands worked as intended, then a regular STDOUT message should suffice. Of course, using useful error messages and sucess messages will be vital to maximizing the efficiency of STDERR and STDOUT usage within a custom shell.

- How should our custom shell handle errors from commands that fail? Consider cases where a command outputs both STDOUT and STDERR. Should we provide a way to merge them, and if so, how?

    > **Answer**: Whenever the shell encounters errors from failed commands, one of the first measures sould be that descriptive error messages are displayed to the user through the CLI, which are corresponding to other STDERR messages with error status codes. Users should be able to interpret the error message and understand if the command failed because of missing flags, command misuse, or other related issues. The shell should be able to handle errors such as exceeding the number of allocated commands, buffer overflows, too little or too many arguments for any type of command, no commands, missing commands between piping, improper pipe seperator, and any type of command misuse through the strategies listed. There shouldn't be program crashes or runtime errors when a command fails, as normal shells would display useful information before asynchronously waiting for the next command. Errors should also be logged in some sort of output format, so that developers can monitoring invalid commands and possibly provide fixes or suggestions on addressing the failures. In some cases that a command might output both STDOUT and STDERR, there should be a way to merge these merges. As previously mentioned, assuming we implemented a merge redirection, it might be possible redirect the error messages and success messages that are marked with STDERR and STDOUT, respectively, from the command into a output file. 