1. Can you think of why we use `fork/execvp` instead of just calling `execvp` directly? What value do you think the `fork` provides?

    > **Answer**: The reason that we use `fork/execvp`, instead of simply calling `execvp` is that `fork()` will create a new child process from the original parent process. However, without this child process, a child process would never be created by `execvp`, but instead the function perserves file descriptions, allowing the binary of the child process to run concurrently and the parent process to wait for the process to finish. `fork()` not only creates the subprocess, but the child process can still have the equivalent memory allocations, file descriptors, and execution states, making it an effective pattern to implement for our shell.


2. What happens if the fork() system call fails? How does your implementation handle this scenario?

    > **Answer**: Whenever `fork()` fails, the function should return a negative integer (-1) to indicate that the child process of the parent process was not created sucessfully. Within my program, I used conditional statements to check the value is less than 0, it would return one of the designated error codes pertaining to command execution because of the fact that 0 is returned if the fork process was done correctly.

3. How does execvp() find the command to execute? What system environment variable plays a role in this process?

    > **Answer**: `execvp()` locates the command to execute by referencing the many directories that are associated with the `PATH` system environment variable. To elaborate, the `PATH` environmental variable contains searchable directories that can be accessed within shell interfaces for a given executable command to run and perserve the child process, which is not its sole purpose, but is perfect for this use case. Since `execvp()`doesn't create the child process, the current process can be overriden with the new child process that was forked.

4. What is the purpose of calling wait() in the parent process after forking? What would happen if we didnâ€™t call it?

    > **Answer**: The purpose of calling `wait()` in the parent process after forking forces the parent to wait for its child process to complete before proceeding forward. If we didn't call the `wait()` function, it could lead to the parent process terminating before the child process has finished, which is known as a zombie process that takes up unecessary resources that can be distributed to other processes. With an influx of zombie processes, this could lead to really poor process management and an bottleneck of available resources that are designated for system processes.

5. In the referenced demo code we used WEXITSTATUS(). What information does this provide, and why is it important?

    > **Answer**: Based off of the demo code, `WEXITSTATUS()` acts as macro within the Clang's runtime library that retrieves the return code from a waiting process. In our situation, we are trying to retrieve the exit code from the child process, as this information is cruial for telling us if we have errors with the execution of the subprocess. Error codes are information and additional information gives the developers more leeway when it comes to debugging the child process from its parent process.

6. Describe how your implementation of build_cmd_buff() handles quoted arguments. Why is this necessary?

    > **Answer**: In my code of build_cmd_buff, I handled quoted arugments by representing a boolean value as an integer and while parsing the user inputted command, I would check for a single quote character, which woudl be indictive that there is an opening quote character for whatever built-in command (echo, awk), which sets the integer of quotes to 1. Afrer reaching the end of the string literal, we want to check if we are inside of quotes, meaning that this might be a string argument, and we can iterate through the rest of the string literal to find the ending quote. Upon finding this quote character, we can reset the quote integer back to 0, null-terminate the literal and continue onwards. This is extremely important in shell development because there might be built-in or external commands that require string literals like echo, which would not be able to be parsed properly, as it would treat the string as multiple arguments. In addition, any command with multiple quotation marks might mess up the parsing of the command buffer. 

7. What changes did you make to your parsing logic compared to the previous assignment? Were there any unexpected challenges in refactoring your old code?

    > **Answer**: In terms of parsing logic, I feel that I had to make several changes because of how poorly my code was written in A3. For our command inputs during this assignment, we were not tokenizing the string literals based off strings, so that had to be completely change, where we can also handle quoted string arugments. `build_cmd_buff(...)` takes the entire command that the user inputs into the shell and processes it as one command, whereas the pipes were used to parse each command in separate parts in the last assignment. The biggest challenge that I ran into for this assignment was trying to figure out how to parse multiple quotes, where I tried modular math to account for odd and even number of quotes, but I found that to be problematic. Since we were using command_t before, the population of the cmd_buff_t struct was handled differently, which had its own challenges.

8. For this quesiton, you need to do some research on Linux signals. You can use [this google search](https://www.google.com/search?q=Linux+signals+overview+site%3Aman7.org+OR+site%3Alinux.die.net+OR+site%3Atldp.org&oq=Linux+signals+overview+site%3Aman7.org+OR+site%3Alinux.die.net+OR+site%3Atldp.org&gs_lcrp=EgZjaHJvbWUyBggAEEUYOdIBBzc2MGowajeoAgCwAgA&sourceid=chrome&ie=UTF-8) to get started.

- What is the purpose of signals in a Linux system, and how do they differ from other forms of interprocess communication (IPC)?

    > **Answer**: The purpose of signals within a Linux system is that they are indications of different environmental circumstances that comes from some event. In simpler terms, whenever system calls occur, the reciprocated response is in a form of signal from some action within the system that will give the developer information about the sucess of a subprocess. Signals are different than other forms of IPC because they lack communication between different processes, but are simply notifiers of a given interaction. Other IPCs like pipes and sockets are used in different system architectures to communnicate between each other, they are extremely lightweight since the signal code is indicative of the success of the process without acknowledging the child process it came from.

- Find and describe three commonly used signals (e.g., SIGKILL, SIGTERM, SIGINT). What are their typical use cases?

    > **Answer**: The SIGKILl signal can be used to indicate kill the process instantaneously, which cannot be captured or ignored from the kernel. Developers may use a SIGKILL signal to stop an unresponsive program from an infinite running process that is consistently draining resources. SIGTERM signal also terminates the process, but it handles the termination process more gracefully, but allowing the signal to be caught and processed by the system first. The use case for SIGTERM could be applied to web development, when you are done running your server for your web application and are preparing to shut down the server process, you can allow any cleanup or cache clearing from the server to be gracefully stored and exited. Lastly, the SIGINT signal can be used to interupt a running process and is commonly associated with the CTRL+C shortcut on your system, which can still be caught and handled before shutting off. The use case for SIGINT is if you deploy a production pod from Kubernetes with continously incoming requests to your API server and wanted to stop the CLI tool from displaying the output, you can use the SIGINT signal to interrupt the process.

- What happens when a process receives SIGSTOP? Can it be caught or ignored like SIGINT? Why or why not?

    > **Answer**: Whenever a process recieves a SIGSTOP signal, the process will be stopped/suspended until other signals are recieved to instruct the program to continue with its operations. While SIGINT can be caught and/or ignored, SIGSTOP cannot be caught and/or ignored because the signals is supposed to stop a process without further questions, so that the suspension cannot be prevented, regardless of the state or permissions of the process.