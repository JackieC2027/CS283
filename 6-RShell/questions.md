1. How does the remote client determine when a command's output is fully received from the server, and what techniques can be used to handle partial reads or ensure complete message transmission?

Within the remote client, it can determine a command's output is fully recieved from the server by referencing message symbols that are indicating that the current stream of user input has concluded. Symbols such as EOF characters that were defined in the header files can be used to indicate that the server can process the incoming request of information. Additionally, the remote client can possibly transmit data to the server that would inform the server of the conclusion of message transmissions, if the server was able to parse the number of characters that the request has. Some of the techniques that can be used to handle partial reads and ensure complete message transmission would be use iterative methods to continue reading from the incoming client socket stream until an EOF character is reached or the parsed length of the incoming user's socket has surpassed some threshold. 

2. This week's lecture on TCP explains that it is a reliable stream protocol rather than a message-oriented one. Since TCP does not preserve message boundaries, how should a networked shell protocol define and detect the beginning and end of a command sent over a TCP connection? What challenges arise if this is not handled correctly?

A networked shell protocol should define and detect the beginning and end of a command sent over TCP connection by invoking fixed separators betweene ach message stream, so that if we reach the separator between each message, especially when we are dealing with multi-threading, so taht we can easily parse messages in their whole form. Using escape characters to fill the spaces between messages can create artifical boundaires between the end and start of a command, which can be easily iteratively parsed. Some of the challenges that can appear if these message boundaries are not properly established could be that threaded messages are recongized as one entire command, leading to the adverse effects of combining two different system calls, the server could parse the command as an invalid command, even though the built-in command shell would be able to parse it normally, resources for the message that were allocated can go rampant and infinitely parse a single command, essentially taking up resources from the server that could be used to handle more computationally heavy commands in the server.

3. Describe the general differences between stateful and stateless protocols.

The general differences between stateful and stateless protocols would be the presence of sessions, where stateful protocols are usually identifying and tracking information about the client between requests and responses, adding more necessary resources to store the change in state between the client and the server; these protocols rely on a system to manage the state constantly to avoid data corruption between the server and the client, potential bottlenecks, and reverting algorithms to prevent the loss of data within the server. On the other hand, stateless protocols do not need to store the context or session information about the interactions between the client and the server, meaning that there is less demanding resource pool for these protocols, in comparison to stateful protocols, allowing the server to complete whatever request that the user needs and proceed to scale this system to x amount of users.

4. Our lecture this week stated that UDP is "unreliable". If that is the case, why would we ever use it?

Although UDP is unreliable, system programmers are willing to sacrifice its reliability for its low latency protocol, allowing for firms that are building high-frequency trading systems or low latency networks to transmit RESTful data between API gateways to quickly transmit data from A -> B. Without a proper connection or error handling, the protocol can quickly send this data, at the expense of possibly losing some data during transmission or that the network packets could arrive out of order.

5. What interface/abstraction is provided by the operating system to enable applications to use network communications?

From the operating system, the interface/abstraction that allows applications to use network communication is the socket API, which allows system programmers to access the internet through certain protcols and send data to another system/program. 